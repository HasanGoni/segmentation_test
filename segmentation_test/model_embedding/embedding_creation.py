# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/18_model_embedding.embedding_creation.ipynb.

# %% auto 0
__all__ = ['EmbeddingExtractor', 'visualize_embeddings']

# %% ../../nbs/18_model_embedding.embedding_creation.ipynb 3
from cv_tools.core import *
from cv_tools.imports import *
import matplotlib.pyplot as plt
from sklearn.manifold import TSNE
from umap import UMAP



# %% ../../nbs/18_model_embedding.embedding_creation.ipynb 4
import torch.nn as nn
import torch


# %% ../../nbs/18_model_embedding.embedding_creation.ipynb 5
from private_front_easy_pin_detection.pytorch_model_development import UnetManualMaxPoolOnly
from private_front_easy_pin_detection.dataloader_creation import *
from private_front_easy_pin_detection.model_eval.create_mask import *


# %% ../../nbs/18_model_embedding.embedding_creation.ipynb 10
class EmbeddingExtractor(nn.Module):
    def __init__(self, model):
        super().__init__()
        self.model = model
        self.encoder = model.encoder
        
    def forward(self, x):
        c1, c2, c3, c4, c5 = self.encoder(x)
		# c5 deepest embedding bottleneck
        return {
            'c1': c1,
            'c2': c2,
            'c3': c3,
            'c4': c4,
            'c5': c5
		}
    

# %% ../../nbs/18_model_embedding.embedding_creation.ipynb 13
def visualize_embeddings(embeddings, labels, method='tsne', level='c5'):
    """
    Visualize embeddings using t-SNE or UMAP
    """
    plt.figure(figsize=(10, 8))
    
    # Get embeddings for specified level
    X = embeddings[level]
    
    # Reduce dimensionality
    if method == 'tsne':
        reducer = TSNE(n_components=2, random_state=42)
    else:
        reducer = UMAP(n_components=2, random_state=42)
    
    X_reduced = reducer.fit_transform(X)
    
    # Create scatter plot
    scatter = plt.scatter(X_reduced[:, 0], X_reduced[:, 1], 
                         c=labels, cmap='tab10', alpha=0.6)
    plt.colorbar(scatter)
    plt.title(f'{method.upper()} visualization of {level} embeddings')
    plt.xlabel(f'{method.upper()} 1')
    plt.ylabel(f'{method.upper()} 2')
    plt.show()
